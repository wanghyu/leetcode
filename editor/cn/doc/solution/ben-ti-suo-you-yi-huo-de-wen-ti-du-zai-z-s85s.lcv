**1.为什么可以转为01背包？**
答：把字符串看成物品，0和1看成重量，只不过重量变成二维，加的时候每个维度都需要判断一下。
 
**2.dp[k][i][j]或者二维dp[i][j]具体是什么意思？**
答：dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]，dp[k][i][j]：取strs中0-k个字符串，最多有i个0和j个1的strs的最大子集的大小为dp[k][i][j]
 
**3.为什么优化后的代码为倒序？**
答：(有个评论区的写的  我觉得很清楚)1.首先“记录本”不一样了，我本来应该拿三维数组记录的，比如dp[i][m][n]代表前i个字符满足m个0，n个0的最大子集数，这时候我们就顺着来，因为每一个层数我们都会记录，但是递推公式发现只和上一层有关，也就是dp[i][m][n]只和dp[i-1][][]这一层的有关，那么就进行优化。 2.我只用一个二维的“记录本”来记录上一层，也就是dp[m][n]代表的意义是上一层满足m个0和n个1的最大子集数，我没法找到任意一层了，因为我现在只有一个更小的“记录本”，所以我要保证算的过程中，永远能用上一层的数据，我就必须得倒着来，因为正着来的时候，我算dp[m][n] = dp[m-zeros][n-ones]就错了，因为本来要用上一次赋值了的dp[m-zeros][n-ones]结果，你在这一层遍历先赋值了他们，后来才算的dp[m][n]，乱了，上一层数据没了，给你盖住了！ 总之，倒序的目的就是少用一维数组，省下了空间，因为记录那么多层没必要，我只要上一层就ok。
 
**4.为什么递推式dp[i-zero][j-one] + 1有个加一？**
答：dp[i-zero][j-one]表示i-zero个0，j-one个1最多有多少个子集，但是这里意思是我当前这个子集可以添加进去，所以加了一个子集数量，实际上这个1就是背包问题的value，子集数量。
 
**5.代码中循环每个字符串代码去哪里了？**
答：第一个for，实际上就是取出下一个字符串，因为前面的已经统计了，只需要取出下一个就行了，然后统计每一个0和1的次数。
 
**6.代码中对dp数组的初始化去哪里了？**
答：dp[0][0]意思是最多有0个0,0个1的子集有多少个，很显然就是0，java默认值就行了。
 
**7.官解中为什么是max(dp[i][j][k], dp[i - 1][j - zeros][k - ones] + 1)而不是dp[i-1][j][k], dp[i - 1][j - zeros][k - ones] + 1？**
答：两种都是正确的，官解在上一步对dp[i][j][k] = dp[i - 1][j][k]有一个赋值操作，实际上是一样的。

* 

```
官解：
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int length = strs.length;
        int[][][] dp = new int[length + 1][m + 1][n + 1];
        for (int i = 1; i <= length; i++) {
            int[] zerosOnes = getZerosOnes(strs[i - 1]);
            int zeros = zerosOnes[0], ones = zerosOnes[1];
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j >= zeros && k >= ones) {
                        dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - zeros][k - ones] + 1);
                    }
                }
            }
        }
        return dp[length][m][n];
    }

    public int[] getZerosOnes(String str) {
        int[] zerosOnes = new int[2];
        int length = str.length();
        for (int i = 0; i < length; i++) {
            zerosOnes[str.charAt(i) - '0']++;
        }
        return zerosOnes;
    }
}


```

* 

```
优化后
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int dp[][] = new int[m+1][n+1];
        for (String str : strs) {
            int one = 0,zero = 0;
            for (char c : str.toCharArray()) {
                if (c == '0')
                    zero++;
                if (c == '1')
                    one++;
            }
            for (int i = m; i >= zero; i--) {
                for (int j = n; j >= one; j--) {
                    dp[i][j] = Math.max(dp[i][j],dp[i-zero][j-one] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```

